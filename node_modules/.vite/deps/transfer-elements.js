var __typeError = (msg) => {
  throw TypeError(msg);
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);

// node_modules/transfer-elements/dist/transfer-elements.esm.min.js
var _TransferElements_instances, assembleBreakpoints_fn, getChildElementsOfTargetElement_fn, getBreakpointTrigger_fn, getScrollbarWidth_fn, getObjectType_fn, isTargetElementDescendantOfSourceElement_fn, isTagOfTargetElementSelfClosing_fn, sortBreakpointObjects_fn, removeSourceElements_fn, insertSourceElements_fn, throwExceptionIfMaximumTargetPositionIsExceeded_fn, generateBreakpointObject_fn;
var TransferElements = class {
  constructor(...e) {
    __privateAdd(this, _TransferElements_instances);
    if (0 === e.length) throw TypeError("at least one object with parameters must be specified for the constructor");
    const o = [];
    e = e.map((t) => {
      if ("[object Object]" !== __privateMethod(this, _TransferElements_instances, getObjectType_fn).call(this, t)) throw TypeError("the arguments specified for the constructor must be objects of type 'Object'");
      ["sourceElement", "breakpoints"].forEach((e3) => {
        if (!Object.hasOwn(t, e3)) throw TypeError(`the '${e3}' parameter is not specified for the main object`);
      });
      var { sourceElement: e2, breakpoints: r2 } = t;
      if (!(e2 instanceof Element)) throw TypeError("the value specified for the 'sourceElement' parameter must be an object of type 'Element'");
      if (o.includes(e2)) throw TypeError(`there can only be one object in the constructor with such a 'sourceElement': '${e2.cloneNode().outerHTML}'`);
      return o.push(e2), t.breakpoints = __privateMethod(this, _TransferElements_instances, assembleBreakpoints_fn).call(this, r2, e2), t;
    });
    const r = [...e.reduce((t, { breakpoints: e2 }) => (Object.keys(e2).forEach((e3) => {
      Number(e3) && t.add(e3);
    }), t), /* @__PURE__ */ new Set()).add("default")].sort((e2, t) => e2 - t), n = r.reduce((e2, t) => (e2.set(t, []), e2), /* @__PURE__ */ new Map());
    e.forEach(({ sourceElement: o2, breakpoints: e2 }) => {
      Object.entries(e2).forEach(([e3, { targetElement: t, targetPosition: r2 }]) => {
        n.get(e3).push({ sourceElement: o2, targetElement: t, targetPosition: r2 });
      });
    }), n.forEach((t) => {
      __privateMethod(this, _TransferElements_instances, sortBreakpointObjects_fn).call(this, t), __privateMethod(this, _TransferElements_instances, removeSourceElements_fn).call(this, t), __privateMethod(this, _TransferElements_instances, insertSourceElements_fn).call(this, t, true), t.length = 0, o.forEach((e2) => {
        t.push(__privateMethod(this, _TransferElements_instances, generateBreakpointObject_fn).call(this, e2, true));
      }), __privateMethod(this, _TransferElements_instances, sortBreakpointObjects_fn).call(this, t);
    });
    let a = "default";
    new ResizeObserver(([{ borderBoxSize: [{ inlineSize: e2 }], target: t }]) => {
      var e2 = e2 + __privateMethod(this, _TransferElements_instances, getScrollbarWidth_fn).call(this, t), t = __privateMethod(this, _TransferElements_instances, getBreakpointTrigger_fn).call(this, r, e2);
      a !== t && (e2 = n.get(t), __privateMethod(this, _TransferElements_instances, removeSourceElements_fn).call(this, e2), __privateMethod(this, _TransferElements_instances, insertSourceElements_fn).call(this, e2, false), a = t);
    }).observe(document.documentElement);
  }
};
_TransferElements_instances = new WeakSet();
assembleBreakpoints_fn = function(e, n) {
  if ("[object Object]" !== __privateMethod(this, _TransferElements_instances, getObjectType_fn).call(this, e)) throw TypeError("the value specified for the 'breakpoints' parameter must be an object of type 'Object'");
  e = Object.entries(e);
  if (0 === e.length) throw TypeError("at least one breakpoint must be specified for the 'breakpoints' object");
  e = Object.fromEntries(e.map(([e2, t]) => {
    e2 = Number(e2);
    if (!e2 || e2 <= 0 || e2 > Number.MAX_SAFE_INTEGER) throw RangeError("the breakpoint trigger must be a safe (integer or fractional) number greater than zero");
    if ("[object Object]" !== __privateMethod(this, _TransferElements_instances, getObjectType_fn).call(this, t)) throw TypeError("the breakpoint object must be of type 'Object'");
    if (!Object.hasOwn(t, "targetElement")) throw TypeError("the 'targetElement' parameter is not specified for the breakpoint object");
    var { targetElement: r, targetPosition: o } = t;
    if (!(r instanceof Element)) throw TypeError("the value specified for the 'targetElement' parameter must be an object of type 'Element'");
    if (n === r) throw TypeError("the value specified for the 'targetElement' parameter must be different from the value specified for the 'sourceElement' parameter");
    if (__privateMethod(this, _TransferElements_instances, isTargetElementDescendantOfSourceElement_fn).call(this, r, n)) throw TypeError("the element that is specified as the value for the 'targetElement' parameter must not be a descendant of the element specified as the value for the 'sourceElement' parameter");
    if (__privateMethod(this, _TransferElements_instances, isTagOfTargetElementSelfClosing_fn).call(this, r)) throw TypeError("the element specified as the value for the 'targetElement' parameter must be a paired tag");
    if (Object.hasOwn(t, "targetPosition")) {
      if ("number" != typeof o) throw TypeError("the value specified for the 'targetPosition' parameter must be of type 'number'");
      if (o < 0 || !Number.isSafeInteger(o)) throw RangeError("the number specified as the value for the 'targetPosition' parameter must be a non-negative safe integer");
    }
    return [e2, { targetPosition: o ?? 0, ...t }];
  }));
  return e.default = __privateMethod(this, _TransferElements_instances, generateBreakpointObject_fn).call(this, n, false), e;
};
getChildElementsOfTargetElement_fn = function(e) {
  return e.children;
};
getBreakpointTrigger_fn = function(e, t) {
  let r = 0, o = e.length - 2, n;
  for (; r <= o; ) {
    var a = Math.floor((r + o) / 2), i = e[a];
    if (i == t) return i;
    t < i ? o = a - 1 : r = a + 1, 0 < i - t && (n = i);
  }
  return n ?? "default";
};
getScrollbarWidth_fn = function(e) {
  var t = window.innerWidth, e = Math.min(e.clientWidth, e.offsetWidth);
  let r = 0;
  return e !== t && (r += t - e), r;
};
getObjectType_fn = function(e) {
  return Object.prototype.toString.call(e);
};
isTargetElementDescendantOfSourceElement_fn = function(e, t) {
  for (; e = e.parentElement; ) if (e === t) return true;
  return false;
};
isTagOfTargetElementSelfClosing_fn = function(e) {
  return !new RegExp(/<\/[a-zA-Z]+>$/).test(e.outerHTML);
};
sortBreakpointObjects_fn = function(e) {
  1 < e.length && e.sort((e2, t) => e2.targetPosition - t.targetPosition);
};
removeSourceElements_fn = function(e) {
  e.forEach(({ sourceElement: e2 }) => {
    e2.remove();
  });
};
insertSourceElements_fn = function(e, n) {
  e.forEach(({ sourceElement: e2, targetElement: t, targetPosition: r }) => {
    var o = __privateMethod(this, _TransferElements_instances, getChildElementsOfTargetElement_fn).call(this, t), o = (n && __privateMethod(this, _TransferElements_instances, throwExceptionIfMaximumTargetPositionIsExceeded_fn).call(this, o, r), o[r]);
    o ? o.before(e2) : t.append(e2);
  });
};
throwExceptionIfMaximumTargetPositionIsExceeded_fn = function(e, t) {
  e = e.length;
  if (e < t) throw RangeError(`the number specified as the value for the 'targetPosition' parameter exceeds the maximum allowed value of '${e}'`);
};
generateBreakpointObject_fn = function(t, e) {
  var r = t.parentElement, r = { targetElement: r, targetPosition: [...r.children].findIndex((e2) => e2 === t) };
  return e && (r.sourceElement = t), r;
};
export {
  TransferElements as default
};
/*! Bundled license information:

transfer-elements/dist/transfer-elements.esm.min.js:
  (**
   * @file Dynamic transfer of elements from one place to another at breakpoints.
   * @copyright SineYlo, 2024
   * @version 1.0.7
   * @license MIT
   *)
*/
//# sourceMappingURL=transfer-elements.js.map
